\documentclass[11pt]{article}

\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\selectlanguage{polish}
\usepackage{graphicx}
\usepackage{float}
\usepackage[a4paper, total={6.5in, 9.5in}]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[hidelinks]{hyperref}
\usepackage{tabularx}
\usepackage{fancyhdr}
\pagestyle{fancy}

\urlstyle{rm}
  
\usepackage{setspace}
\newtheorem{stat}{Statement}
\newtheorem{theorem}{Theorem}
\newtheorem{defi}{Definition}
\newtheorem{lem}[stat]{Lemma}
\newtheorem{ex}{Example}[section]
\newtheorem{fact}{Fact}

\frenchspacing

\begin{document}


\title{Bank Marketing data (with social/economic context)}
\author{Maciej Ma³ecki}
\maketitle
\abstract{W pliku Bank Marketing data.csv znajduj¹ siê dane charakteryzuj¹ce klientów pewnego banku oraz kampanie marketingowe skierowane do tych klientów. Do³¹czone s¹ ponadto wskaŸniki spo³eczne i ekonomiczne. Na podstawie tych danych nale¿y zbudowaæ model prognozuj¹cy szansê, ¿e klient w wyniku prowadzonej kampanii za³o¿y lokatê terminow¹.}
\tableofcontents

\newpage

\section{Wprowadzenie}
\subsection{Opis problemu}
W ramach kampani marketingowej organizowanej przez pewien bank w latach miêdzy majem 2008 rok, a listopadem 2010 roku, by³y zbierane informacje na temat klientów tego banku. 
Na podstawie tych danych planowane jest przewidzenie, czy i jakie rodzaj klientów kupi lokatê terminow¹ w tym banku.

\subsection{Opis danych}
Nasze dane zawieraj¹ 21 column danych. Kolumny mo¿emy podzieliæ na 3 grupy:

\textbf{I: Zmienne zwi¹zane z danymi klienta bankowego:}

\begin{enumerate}
\item Wiek (age): wiek klienta.
\item Praca (job): rodzaj pracy klienta.
\item Stan cywilny (marital): stan cywilny klienta.
\item Edukacja (education): edukacja klienta.
\item Domyœlnie (default): Klient wczeœniej domyœlnie mia³ kredyt.
\item Mieszkanie (housing): Klient ma kredyt mieszkaniowy.
\item Po¿yczka (loan): Klient ma osobist¹ po¿yczkê.
\end{enumerate}


\textbf{II: Zmienne zwi¹zane z ostatnim kontaktem bie¿¹cej kampanii marketingowej:}

\begin{enumerate}
\setcounter{enumi}{7}
\item Kontakt (contact): Typ komunikacji kontaktowej (telefonicznej lub komórkowej).
\item Miesi¹c (month): Ostatni kontakt miesi¹ca roku.
\item Dzieñ tygodnia (day of week): dzieñ ostatniego kontaktu tygodnia.
\item Czas trwania (duration): czas trwania ostatniego kontaktu w sekundach. Jeœli czas trwania wynosi 0, nigdy nie skontaktowaliœmy siê z klientem, aby za³o¿yæ konto lokaty terminowej.
\item Kampania (campaign): liczba kontaktów wykonanych podczas tej kampanii i dla tego klienta
\item Liczba dni (pdays): liczba dni, które up³ynê³y od ostatniego kontaktu klienta z poprzedniej kampanii (wartoœæ liczbowa; 999 oznacza, ¿e klient wczeœniej siê nie skontaktowa³)
\item Poprzedni (previous): liczba kontaktów wykonanych przed t¹ kampani¹ i dla tego klienta (numerycznie)
\item Poutcome: wynik poprzedniej kampanii marketingowej (kategorycznie: „pora¿ka”, „nieistniej¹ca”, „sukces”)
\end{enumerate}

\textbf{III: Atrybuty kontekstu spo³ecznego i gospodarczego:}

\begin{enumerate}
\setcounter{enumi}{15}
\item Emp.var.rate: wskaŸnik zmiennoœci zatrudnienia - wskaŸnik kwartalny 
\item Cons.price.idx: wskaŸnik cen konsumpcyjnych - wskaŸnik miesiêczny 
\item Cons.conf.idx: wskaŸnik zaufania konsumentów - wskaŸnik miesiêczny 
\item Euribor3m: stawka 3-miesiêczna euribor - wskaŸnik dzienny 
\item Liczba zatrudnionych (nr employed): liczba pracowników - wskaŸnik kwartalny 
\end{enumerate}


\textbf{Zmienna wyjœciowa (po¿¹dany cel):}

\begin{enumerate}
\setcounter{enumi}{20}
\item y - czy klient subskrybowa³ lokatê? (dwójkowy: „tak”, „nie”)
\end{enumerate}

\subsection{Wstêpna eksploracja danych}
<<echo=FALSE,message=FALSE, warning=FALSE>>=
# Library to install
# install.packages('tidyverse')
# install.packages("descr")
# install.packages("tables")
# install.packages("egg")
# # Cross Tables
# install.packages("gmodels")
# # Additional packages for GGplot
# install.packages("ggplot2")
# install.packages("ggmosaic")
# install.packages('corrplot')
# install.packages('ggpubr')
# install.packages('cowplot')
# install.packages("ggimage")
# install.packages('pander')
# # Machine Learning
# install.packages('caret')
# install.packages("ROCR")
# install.packages("plotROC") #patch for ggplot
# install.packages("pROC")
# install.packages("PRROC")
# install.packages("xgboost")
# install.packages("mlr")
# install.packages("randomForest")
# install.packages("kernlab")
# install.packages("MLmetrics")

# Library
library(rmarkdown)
library(pander)
library(tidyverse)
library(kableExtra)
library(gridExtra)
library(DescTools)
library(dplyr)
library(descr, quietly = T)
library(tables, quietly = T)
library(knitr)
#
library(ggplot2)
library(egg)
library(gmodels) 
library(ggmosaic) 
library(corrplot) 
library(ggpubr) 
library(cowplot)
theme_set(theme_bw())
#
library(caret) 
library(ROCR) 
library(plotROC) 
library(pROC)
library(PRROC) 
library(mlr)
library(randomForest)
library(kernlab)
library(xgboost)
library(tidyverse)

######################## Importing data ########################
setwd('C:/Users/Maciek^M/OneDrive/Desktop/Projekty/Bank-Marketing/R version PL')
df_bank <- read.csv(file = "Date/Bank_Marketing_data.csv", 
                    sep = ";",
                    stringsAsFactors = F)
@


Badane dane zawieraj¹ 4119 wierszy oraz 21 kolumn o nastêpuj¹cych nazwach:
<<echo=FALSE ,message=FALSE>>= 
dim <- dim(df_bank)
# dim[1] # number of row
# dim[2] # number of column
@
<<echo=FALSE ,message=FALSE>>= 
names(df_bank) #names of columns
@

Struktura danych:
<<echo=TRUE ,message=FALSE>>= 
str(df_bank)
@

Czy w danych znajduj¹ siê wartoœci typu \verb+NaN+ lub \verb+Na+ ?
<<echo=FALSE ,message=FALSE>>= 
any(is.na(df_bank))
@

Jednak¿e wiemy, ¿e w danych wystêpuj¹ wartoœci brakuj¹ce i s¹ one opisa "unknown". W danych znajduje siê 1230  rekordów z wartoœci¹ "unknown" rozmieszczonych w 1029 ró¿nych wierszach. To stanowi $24.98\% $ wszystkich wierszy w naszej badzie danych, wiêc nie mo¿emy pozwoliæ sobie na usuniêcie tych wszystkich informacji. W tabeli 1 znajduj¹ siê informacje na temat liczny nieznanych wartoœci  w ka¿dej z kolumn z osobna.

<<echo=FALSE ,message=FALSE>>= 
number_of_unknown <- sum(df_bank == 'unknown')
@


<<kable ,echo=FALSE ,message=FALSE, warning=FALSE>>= 
table_unknown <- df_bank %>%
    summarise_all(list(~sum(. =='unknown'))) %>%
    gather(key = 'Feature', value = 'Number of unknown')  %>%
    arrange(desc(Number_of_unknown))

df_bank1 <- df_bank %>%
    mutate_if(is.character, list(~na_if(., "unknown")))
number_of_empty_row <- dim(df_bank)[1] - dim(df_bank1[complete.cases(df_bank1), ])[1]
per_unknown <- round(number_of_empty_row/dim(df_bank)[1]*100, 2)

table_unknown
@
\newpage

\section{Analiza eksploracyjna}
<<echo=FALSE ,message=FALSE>>= 
###### Function 
fun_barplot_categorical <- function(x_column, xlabel, fill_column='y'){
    # x_column: (str) name of column with dataframe
    # fill_column: (str) name of column with dataframe which we fill
    # xlabel: (str) name of x label
    gg1 <- ggplot(data = df_bank, aes_string(x = x_column , fill = fill_column)) +
        geom_bar(position = "dodge2") +
        theme(axis.text.x = element_text(angle = -35,  hjust = 0)) +
        scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
        scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
        labs(x = xlabel, y = "Count")
    
    gg2 <- ggplot(data = df_bank, aes_string(x = x_column, fill = fill_column)) +
        geom_bar(position = "fill") +
        theme(axis.text.x = element_text(angle = -35,  hjust = 0)) +
        scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
        scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
        labs(x = xlabel, y="Percent of population")
    
    
    plot_grid(gg1, gg2,
              nrow =2,
              labels = c("a)", "b)"))
}


############@
fun_histogram <- function(main_column, xlabel, xmin=0, xmax=20, bins=50){
    # main_column: (str) name of column with dataframe
    # xlabel: (str) name of x label
    # limit_breaks: (int) x limit
    gg <- ggplot(df_bank, aes_string(x=main_column, color="y", fill="y")) +
        geom_histogram(aes(y=..density..), position="identity", alpha=0.5, bins = 70)+
        geom_density(alpha=0.2)+
        facet_grid(y ~ ., scales = 'free_y') +
        scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
        scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
        scale_x_continuous(breaks = seq(xmin, xmax, bins)) +
        labs(x = xlabel, 
             y = "Density")+
        theme_classic()
    return(gg)
}


############@
fun_boxplot <- function(column, ylabel){
    # column: (str) name of column with dataframe
    # ylabel: (str) name of y label
    ggplot(data = df_bank, aes_string(x = "y", y = column)) +
        stat_boxplot(geom = "errorbar", width = 0.6) +
        geom_boxplot(aes(fill = y)) +
        scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
        scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"))+
        labs(x = "Long-term deposit taken",
             y = ylabel)
}


############@
fun_crosstable <- function(column1, column2="y"){
    # column1: (str) name of first column with dataframe to CrossTable
    # column2: (str) name of second column with dataframe to CrossTable
    return(CrossTable(df_bank[, column1], df_bank[, column2], 
                      prop.r = T, 
                      prop.c = F, 
                      prop.t = F, 
                      prop.chisq = F,
                      dnn = c(column1, column2)))
}

#############################################################
fun_important_feature_ggplot = function(model){
    # Function do present most importent variable in us model
    # model: model used to plot variable importances
    if (class(model)[1] == "ranger"){
        imp_df = model$variable.importance %>% 
            data.frame("Overall" = .) %>% 
            rownames_to_column() %>% 
            rename(variable = rowname) %>% 
            arrange(-Overall)
    } else {
        imp_df = varImp(model) %>%
            rownames_to_column() %>% 
            rename(variable = rowname) %>% 
            arrange(-Overall)
    }
    
    # first panel (half most important variables)
    gg1 = ggplot(data = imp_df, aes(x = reorder(variable, Overall), weight = Overall, fill = -Overall)) +
        geom_bar() +
        coord_flip() +
        labs(x = "Variables",
             y = "Importance") +
        theme(legend.position = "none")
    
    imp_range = ggplot_build(gg1)[["layout"]][["panel_params"]][[1]][["x.range"]]
    imp_gradient = scale_fill_gradient(limits = c(-imp_range[2], -imp_range[1]),
                                       low = "#132B43", 
                                       high = "#56B1F7")
    
    
    return(gg1 + imp_gradient)
}

#################
fun_ROC_PR_curve_ggplot = function(df) {
    # df: dataset generate by generateThreshVsPerfData
    # info in data: 
    #learner - type of model
    #ppv - precision
    #tpr - recall
    #tnr - specificity
    #threshold 
    
    data <- df$data
    
    roc_curve_test <- data %>%
        mutate(tnr = 1-tnr) %>%
        ggplot()+
        aes(x = tnr, y = tpr, colour = learner)+
        geom_line(size=1) +
        xlab("Spenificity") +
        ylab("Sensitivity")+
        ggtitle("ROC Curve", subtitle = "Validation dataset")
    
    pr_curve_test <- ggplot(data, aes(x = tpr, y = ppv, colour = learner))+
        geom_line(size=1) +
        xlab("Recall") +
        ylab("Precision")+
        ggtitle("PR Curve", subtitle = "Validation dataset")
    
    curves_test = ggarrange(roc_curve_test, pr_curve_test, 
                            common.legend = T,
                            legend = "bottom")
    
    return(curves_test)
}


@

W tej sekcji zostanie omówiony ka¿dy parametr z osobna. Nastêpnie dane zostan¹ odpowiednio przygotowane do wykorzystania ich w modelach predykcyjnych.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{Age}
Przedzia³ wiekowy osób bior¹cych kredyt szacuje siê miedzy 18 rokiem ¿ycia, a 88 rokiem ¿ycia. Jednak¿e mo¿na zauwa¿yæ,
¿e osoby które ukoñczy³y 60 rok ¿ycia z wiêksz¹ chêci¹ bra³y lokaty, ni¿ tego nie robi³y. Œredni wiek utrzymuje siê na poziomie 40 lat.
Wiedz¹c, ¿e osoby odk³adaj¹ na lokaty fundusze wtedy, kiedy dobrze zaczynaj¹ zarabniaæ to podzieli³bym ludzi ze wzglêdu na wiek.
 Miêdzy wiekiem [MIN, 30] <- young, [30,65] <- worker, [65, MAX] <- pensioner. Taki podzia³ powinien u³atwiæ analizê przysz³ych algorytmów.

<<echo=FALSE ,message=FALSE,cache=TRUE>>= 
name_of_column <- 'age'
name_of_label <- 'Age'
@

<<echo=FALSE,message=FALSE,cache=TRUE, warning=FALSE>>= # Wyœwietl tabele
summary(df_bank$age)
@

<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=2.9,fig.width=8,fig.align='center',fig.pos='H',fig.cap='Histogram wieku klientów w zale¿noœci od wziêcia lokaty d³ugoterminowej.'>>= #Wyœwietl obrazek bez kodu
fun_histogram(name_of_column, name_of_label, 15, 88, 5)
@

<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=2.9,fig.width=8,fig.align='center',fig.pos='H',fig.cap='Boxplot wieku klientów w zale¿noœci od wziêcia lokaty d³ugoterminowej.'>>= #Wyœwietl obrazek bez kodu
fun_boxplot(name_of_column, name_of_label)
@

<<echo=FALSE, message=FALSE,cache=TRUE, warning=FALSE>>=
df_bank <- df_bank %>%
    mutate(age_categorical = if_else(age < 65 , if_else(age >= 30, 'worker', 'young'), "pensioner")) %>%
    select(-age)
@

%---------------------------------------------------------------------------------------------------------------------------------------%
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Job}
W tej kolumnie mamy 39 wartoœci nieznanych, co stanowi ledwo 1\% ca³ego zbioru, wiêc pozbywamy siê wierszy, które zawieraj¹ tê informacjê.

<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center', fig.pos='H', fig.cap= "Barplot  a)  przedstwiaj¹cy jak wiele osób  za³o¿y³o lokatê w zale¿noœci od zawodu, b) przedstwiaj¹cy stosunek procentowy osób,  które za³o¿y³y lokatê z zale¿noœci od pracy.">>= 

name_of_column <- 'job'
name_of_label <- 'Job'
fun_barplot_categorical(name_of_column, name_of_label)
@

%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Marital status}
Sytuacja taka sama jak przy kolumnie 'job'. Mamy tutaj nieznane wartoœci, ale stanowi¹ one tylko 0.3\% wszystkich danych, wiêc równie¿ usuwamy te wiersze.

<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center',fig.pos='H', fig.cap='Barplot  a) przedstwiaj¹cy jak wiele osób za³o¿y³o lokatê w zale¿noœci od stanu cywilnego; b) przedstwiaj¹cy stosunek procentowy osób, które za³o¿y³y lokatê z zale¿noœci od stanu cywilnego.' >>= 
name_of_column <- 'marital'
name_of_label <- 'Marital status'
fun_barplot_categorical(name_of_column, name_of_label)
@

<<echo=FALSE, message=FALSE,cache=TRUE>>= #Wyœwietl obrazek bez kodu
df_bank <- df_bank %>%
    filter(marital != "unknown")
@


%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Education}
Pula klientów bêd¹cymi 'illiterate' zawieta tylko jedn¹ osobê, wiêc statystycznie taka obserwacja nic nam nie daje.
Natomiast w tym przypadku mamy problem z nieznanymi wartoœciami. Po pierwsze stanowi¹ one 4.1\% wszystkich badanych.
Najbardziej podobne proporcje danych miêdzy 'yes' i 'no' ma categoria klientów, którzu ukoñczyli uniwersytet, wiêc wszystkich klientów 'unknown'
dodam do tej puli klientów.

<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center', fig.pos='H',  fig.cap='Barplot  a) przedstwiaj¹cy jak wiele osób za³o¿y³o lokatê w zale¿noœci od poziomu wykszta³cenia; b) przedstwiaj¹cy stosunek procentowy osób, które za³o¿y³y lokatê z zale¿noœci od poziomu wykszta³cenia.'>>= 
name_of_column <- 'education'
name_of_label <- 'Education level'
fun_barplot_categorical(name_of_column, name_of_label)
@

<<echo=FALSE, message=FALSE,cache=TRUE>>= #Wyœwietl obrazek bez kodu
df_bank <- df_bank %>% 
    filter(education != "illiterate") %>%
    mutate(education = recode(education, "unKnown" = "university.degree"))
@


%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Has credit in default?}
Ta kolumna nie przedstawia wystarczaj¹cej iloœci danych o osóbach, które domyœlnie wzie³y ten kredyt.
Z tego powodu ta kolumna nie bêdzie mia³a ¿adnego wiêkszego wp³ywu na nasze modele, dlatego j¹ usuwamy.
<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center', fig.pos='H',  fig.cap='Barplot  a) przedstwiaj¹cy jak wiele osób za³o¿y³o lokatê w zale¿noœci od posiadania kredytu; b) przedstwiaj¹cy stosunek procentowy osób, które za³o¿y³y lokatê z zale¿noœci od posiadania kredytu.'>>= 
name_of_column <- 'default'
name_of_label <- 'Has credit in default?'
fun_barplot_categorical(name_of_column, name_of_label)
@

<<echo=FALSE, message=FALSE,cache=TRUE>>= #Wyœwietl obrazek bez kodu
df_bank <- df_bank %>% 
    select(-default)
@


%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Has personal loan?}
W tej kolumnie znajduj¹ siê informacje na temat posiadania kredytu hipotecznego (kredytu na dom). Iloœæ danych nieznanych odpowiada, 2,5\% wszystkich obserwacji,
Nie mo¿emy pozwoliæ sobie na usuniêcie tak du¿ej liczny wierszy, a pod³aczenie do jakieœ innej opcji nie wchodzi w grê.
PrzeprowadŸmy testy na niezale¿noœæ zmiennych kategorycznych. Wykonamy test chisq w zelu zbadania niezale¿noœci miêdzy 2 zmiennymi.
<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center', fig.pos='H',  fig.cap='Barplot  a) przedstwiaj¹cy jak wiele osób za³o¿y³o lokatê w zale¿noœci od ju¿ posiadanej po¿yczki; b) przedstwiaj¹cy stosunek procentowy osób, które za³o¿y³y lokatê z zale¿noœci od posiadanej po¿yczki.'>>= 
name_of_column <- 'housing'
name_of_label <- 'Has housing loan?'
fun_barplot_categorical(name_of_column, name_of_label)

@

<<echo=FALSE, message=FALSE,cache=TRUE>>= #Wyœwietl obrazek bez kodu
chisq.test(df_bank$housing, df_bank$y)
@
Niestety poziom istotnoœci(p-value) na poziomie 73\% œwiadczy o du¿ej zale¿noœci miêdzy danymi, wiêc tej zmiennej ró¿nie¿ nie bêdê bra³ pod uwagê.
<<echo=FALSE, message=FALSE,cache=TRUE>>= #Wyœwietl obrazek bez kodu
df_bank <- df_bank %>% 
    select(-housing)
@


%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Has credit in default?}
W tej kolumnie znajduj¹ siê informacje na temat posiadania kredytu. Sytuacja jest ta sama co w przypadku kredytu hipotecznego.
Nie mo¿emy pozwoliæ sobie na usuniêcie tak du¿ej liczny wierszy (2.5\%), a pod³aczenie do jakieœ innej opcji nie wchodzi w grê.
Wykonamy test chisq w zelu zbadania niezale¿noœci miêdzy 2 zmiennymi.
<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center', fig.pos='H',  fig.cap='Barplot  a) przedstwiaj¹cy jak wiele osób za³o¿y³o lokatê w zale¿noœci od domyœlnie posiadanego kredytu; b) przedstwiaj¹cy stosunek procentowy osób, które za³o¿y³y lokatê z zale¿noœci od domyœlnie posiadanego kredytu.'>>= 

name_of_column <- 'loan'
name_of_label <- 'Education level'
fun_barplot_categorical(name_of_column, name_of_label)
@

<<echo=FALSE, message=FALSE,cache=TRUE>>= #Wyœwietl obrazek bez kodu
chisq.test(df_bank$loan, df_bank$y)
@
Poziom istotnoœci(p-value) na poziomie 56.8\% œwiadczy o du¿ej zale¿noœci miêdzy danymi, wiêc tej zmiennej ró¿nie¿ nie bêdê bra³ pod uwagê.

<<echo=FALSE, message=FALSE,cache=TRUE>>= #Wyœwietl obrazek bez kodu
df_bank <- df_bank %>% 
    select(-loan)
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Contact communication type}
Osoby, z którymi próbowano siê skontaktowaæ na telefon komórkowy stanowi¹ 64.4\% ca³ej badanej spo³ecznoœci i co 6 osoba z nich wzie³a lokatê d³ugoterminow¹.
<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center', fig.pos='H',  fig.cap='Barplot a) przedstwiaj¹cy jak wiele osób za³o¿y³o lokatê w zale¿noœci od sposobu kontaktu z klientem; b) przedstwiaj¹cy stosunek procentowy osób, które za³o¿y³y lokatê z zale¿noœci od sposobu kontaktu z klientem.'>>= 
name_of_column <- 'contact'
name_of_label <- 'Contact'
fun_barplot_categorical(name_of_column, name_of_label)

@


%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Last contact month of year}
Ciekaw¹ sutuacj¹ jest fact, ¿e w zestawieniu w ogóle nie mamy tranzakcji ze stycznia oraz z lutego.

<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center', fig.pos='H',  fig.cap='Barplot  a) przedstwiaj¹cy jak wiele osób za³o¿y³o lokatê w zale¿noœci od miesi¹ca, w którym kontaktowano siê z klientem; b) przedstwiaj¹cy stosunek procentowy osób, które za³o¿y³y lokatê z zale¿noœci od miesi¹ca, w którym kontaktowano siê z klientem.'>>= 
name_of_column <- 'month'
name_of_label <- 'Month'
fun_barplot_categorical(name_of_column, name_of_label)
@


%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Last contact day of the week}
W ka¿dym roboczym dniu tygodnia jest wykonywane mniej wiêcej tyle samo po³¹czeñ z klientami,
wiêc nie jesteœmy w stanie wyci¹gn¹æ ¿adnych wiêkszych wniosków, z obserwacji samych wykresów.
<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center', fig.pos='H',  fig.cap='Barplot  a) przedstwiaj¹cy jak wiele osób za³o¿y³o lokatê w zale¿noœci od dnia, w którym kontaktowano siê z klientem; b) przedstwiaj¹cy stosunek procentowy osób, które za³o¿y³y lokatê z zale¿noœci od dnia, w którym kontaktowano siê z klientem.'>>= 
name_of_column <- 'day_of_week'
name_of_label <- 'Day of week'
fun_barplot_categorical(name_of_column, name_of_label)

@


\subsection{Last contact duration, in seconds}
Czas trwania ostatniego kontaktu jest atrybutem, który ma du¿y wp³yw na cel wyjœciowy (y)
Wa¿na uwaga: ten atrybut ma du¿y wp³yw na cel wyjœciowy. Jednak czas trwania nie jest znany przed wykonaniem po³¹czenia.
Ponadto po zakoñczeniu po³¹czenia "y" jest oczywiœcie znane. W zwi¹zku z tym  nale¿y j¹ odrzuciæ, jeœli chcemy stworzenie realistycznego modelu predykcyjnego.
<<echo=FALSE, message=FALSE,cache=TRUE>>=
df_bank = df_bank %>% 
    select(-duration)
@


%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Campaign}
W tej kolumnie zawieraj¹ siê informacje dotycz¹ce liczby po³¹czeñ do danego klienta w ramach kampani.
Przygl¹daj¹c siê boxplotowi mo¿emy zauwa¿yæ, ¿e obserwacje od 7 s¹ ju¿ uwa¿ane jako wartoœci odstaj¹ce.
W zwi¹zku z czym wszystkie watroœci, które s¹ wiêksze ni¿ 7, ale mniejsze ni¿ 12 zamieniê na 7+, a nastêpnie zamienie na zmienn¹ kategoryczn¹.
Zmienne powyzej 12 odrzucam.
<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center', fig.pos='H',  fig.cap='Barplot  a) przedstwiaj¹cy jak wiele osób za³o¿y³o lokatê w zale¿noœci od liczby wykonanych telefonów do klienta; b) przedstwiaj¹cy stosunek procentowy osób, które za³o¿y³y lokatê z zale¿noœci od liczby wykonanych telefonów do klienta.'>>= 
name_of_column <- 'campaign'
name_of_label <- 'Campaign'
fun_histogram(name_of_column, name_of_label,0, 20, 1)
fun_boxplot(name_of_column, name_of_label)
summary(df_bank$campaign)  #table
@

<<echo=FALSE, message=FALSE,cache=TRUE>>=
df_bank <- df_bank %>%
    filter(campaign <= 12) %>%
            mutate(campaign = if_else(campaign == 1, "1",
                                      if_else(campaign == 2, "2",
                                              if_else(campaign == 3, "3",
                                                      if_else(campaign == 4, "4",
                                                              if_else(campaign == 5, "5",
                                                                      if_else(campaign == 6, "6", "7+")))))))
@

%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Pdays}
Kolumna 'pdays' znajduj¹ siê informacje o iloœci dni od ostatniego kontaktu z klientem podczas poprzedniej kampanii. Jeœli wartoœc wynosi "999" to oznacza, ze nigdy siê z dan¹ osob¹ nie skontaktowane.
Informacja zawarta w tej kolumnie jest zbyt rozproszona i niejednoznaczna. W zwi¹zku z tym t¹ informacjê zamienimy w taki sposób, zeby odpowiada³a na pytanie: czy kontaktowano siê z dan¹ osob¹ w poprzedniej kampani?

<<echo=FALSE, message=FALSE,cache=TRUE>>=
summary(df_bank$pdays)
df_bank <- df_bank %>%
    mutate(pdays_call = if_else(pdays == 999,"no","yes")) %>%
    select(-pdays)
@


\subsection{Previous}
Zmienna 'previous' zawiera informacje dotycz¹ce liczby kontaktów wykonanych przed t¹ kampani¹ do tego klienta. W obecnym stanie, ta zmienna zwraca bardzo podobne wyniki co zmienna "pdays binary".
Poniewa¿ liczba klientów, ¿ którymi kontaktowano siê 2 i wiêcej razy jest wyj¹tkowa ma³a w stosunku do osób, z którymi siê nie kontaktowano to propnujê po³¹czyæ te zmienne w wiêksz¹ ca³oœæ.
Tak przygotowana zmienna powie nam, czy nêkanie osób poprzez czêstrze kontakty telefoniczne daje wymierne skutki.
<<echo=FALSE, message=FALSE,cache=TRUE>>=
df_bank <-  df_bank %>% 
    mutate(previous = if_else(previous >=  2, "2+", if_else(previous == 1, "1", "0")))
@






%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Poutcome}
Czy sukces lub pora¿ka podczas poprzedniej kampani da³y siê odczyæ w obecnej kampani??
Jak najbardziej. A¿ 64.8\% osób chcia³bo przed³u¿yæ swoj¹ lokatê. 14.8\% osób , mimo ¿e ostatnio nie wzieli lokaty to czas to czas miêdzy kampaniami da³ im sporo do myœlenia i spowodowa³,
¿e osoby, z którymi siê kontaktowano w poprzedniej kampani chêtniej bra³y lokatê d³ugoterminow¹ ni¿ osoby, z kótrymi kontaktowano siê pierwszy raz.
<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=8, fig.align='center', fig.pos='H',  fig.cap='Barplot  a) przedstwiaj¹cy jak wiele osób za³o¿y³o lokatê w zale¿noœci od sukcesu w poprzedniej kampanii; b) przedstwiaj¹cy stosunek procentowy osób, które za³o¿y³y lokatê z zale¿noœci od sukcesu w poprzedniej kampanii.'>>= 
name_of_column <- 'poutcome'
name_of_label <- 'Poutcome'
fun_barplot_categorical(name_of_column, name_of_label)
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%---------------------------------------------------------------------------------------------------------------------------------------%
\newpage
%---------------------------------------------------------------------------------------------------------------------------------------%

\subsection{Social and economic context attributes}

Ostatnie 5 wspó³czynników to wskaŸniki spo³eczne oraz ekonomiczne. Analiza ka¿dej z osobna jest nie pokaz³a ¿adnej charakterystycznej cech.
Jednak¿e te zmienne powinny byæ jakoœ skorelowane ze sob¹, wiêc obliczmy macierz korelacji.

<<echo=FALSE, message=FALSE,cache=TRUE, fig.height=6, fig.width=6, fig.align='center', fig.pos='H',  fig.cap='Macierz korelacji miêdzy zmiennymi numerycznymi wystêpuj¹cymi w naszej bazie danych.'>>= 
numeric_column <- names(which(sapply(df_bank, is.numeric)))
df_bank %>%
    select(numeric_column) %>%
    cor() %>%
    corrplot(method = "number",
             type = "upper",
             tl.cex = 0.6,
             tl.offset = 0.3,
             tl.srt = 45)

@

Zgodnie z oczekiwaniami, zmienne spo³eczne i ekonomiczne s¹ silnie ze sob¹ skorelowane. Szczególnym przypadkiem silnego skorelowania charakteryzuje siê zmienna
eps.price.rate, która jest wska¿nikiem zmiennoœci zatrudnienia. W zwi¹zku z czym ta zmienna zostaje usuniêta.

<<echo=FALSE, message=FALSE,cache=TRUE>>=
df_bank <- df_bank %>%
            select(-emp.var.rate)
@


\subsection{y = cel prognocy}
Czyli czy klient korzysta³ lokaty czy nie? (dwójkowy: „tak”, „nie”)
POniewa¿ nie mozeby zostawiæ tej zmiennej w postaci zmiennej characterystycznej, musimy zamieniæ j¹ na zmienn¹ numeryczn¹.


<<echo=FALSE, message=FALSE,cache=TRUE>>=
df_bank <- df_bank %>%
    mutate(y = as.factor(if_else(y == "yes", 1,0)))

@

\section{Obróbka danych na potrzeby modeli}
W tej czêœci zostan¹ wykonane 2 kroki potrzebne do prawid³owego dzia³ania modeli predykcyjnych oraz poprawienia wyników modeli.
\subsuction{Normalizacja}
Celem normalizacji jest ujednolicenie danych wejœciowych, numerycznych poprzez ich przescalowanie. W tym przypadku bêdê skalowa³ dane do rozk³adu normalnego.
<<echo=FALSE, message=FALSE,cache=TRUE>>= #Wyœwietl obrazek bez kodu
norm_df_bank <- normalizeFeatures(df_bank, target = 'y')
@
\subsection{Zamiana zmiennych typu \vert+character+ na \verb+factor+}
¯eby model regresji logistyczne oraz XGBoost mog³y prawid³owo dzia³aæ nale¿y zmieniæ zmienne kategoryczne na zmiennej fikcyjne (dummy variable).
<<echo=FALSE, message=FALSE, ,cache=TRUE>>= #Wyœwietl obrazek bez kodu
norm_df_bank <- mutate_if(norm_df_bank, is.character, as.factor)
factor_column <- names(which(sapply(norm_df_bank, is.factor)))
factor_column <- factor_column[-(length(factor_column)-2)]

dummy_norm_df_bank <- createDummyFeatures(norm_df_bank, 
                                    target = "y",
                                    cols = c(factor_column))
                                        
@

\section{Predykcja modeli}
\subsection{Podzia³ i tworzenie zbioru ucz¹cego i testowego}
Nasze dane s¹ ju¿ prawie gotowe do dzielenia na zbiór treningowy oraz zbiór walidacyjny. W pierwszej kolejnoœci chcia³bym znormalizowaæ nasze dane.
Tak zabieg mo¿e poprawiæ jakoœ niektórych modeli np. logistic regresion. Nastêpnie dane zostan¹ podzielone w stosunku 80/20.
Dane treningowe pos³u¿¹ do wytrenowania naszego modelu, natomiast dane testowe zostan¹ wykorzystane podczas walidacji modelu.

Dane na chwilê obecna wygl¹daj¹ w sposób nastêpuj¹cy

<<echo=FALSE, message=FALSE>>= #Wyœwietl obrazek bez kodu
glimpse(df_bank)
@

<<echo=FALSE,message=FALSE,cache=TRUE>>= 
index_train_list = createDataPartition(dummy_norm_df_bank$y,
                          times = 1,
                          p = 0.8,
                          list = F)

train_bank = dummy_norm_df_bank[index_train_list, ]
test_bank = dummy_norm_df_bank[-index_train_list, ]

CrossTable(train_bank$y)
CrossTable(test_bank$y)
@

\subsection{Dobór miar}
Na tym etapie przystêpujemy do generalnego opisu danych i co hcemy wyci¹gn¹æ z danych:
\begin{iteration}
\item Nasze dane s¹ mocno niezrównowa¿one (stosunek 89/11). To powoduje, ze ³atwo bêdzie nam osi¹gn¹æ wysobie accuracy, które w rzeczywistoœci mo¿e nie oddawaæ dok³adnie tego co chcemy;
\item Nasz model ma przewidywaæ, który klient rzeczywiœcie za³o¿y lokatê d³ugoterminow¹. Patrz¹c na "Confusion matrix", ta miara jest opisana przez True Positive (TP).
\item Pod miar¹ "False Positive" (FP) bêd¹ kryli siê klienci, którzy jeszcze nie bêd¹ gotowi na za³o¿enie lokaty d³ugoterminowej
\item Pod miar¹ "False Negative" (FN) bêd¹ kryli siê klienci, którzy s¹ chêtni za³ozyæ lokatê, jednak¿e ban siê z nimi nie skontaktowa³. Ta miara w naszym przypadku bêdzie przynosiæ najwiêksze straty dla banku.
\item A pod ostatni¹ miar¹ "True negative" (TN) bêd¹ wszyscy klienci banku, którzy rzeczywiœcie nie chc¹ za³o¿yæ lokaty.
\item Czyli, ¿eby maksymalizowaæ zyski musimy skupiæ siê na maksymalizacji miar "Recall", "Precision" oraz f11 score z g³ównym skupieniem siê na f1 score, poniewa¿ jest to œrednia harmoniczna z "Recall" oraz "Precision".
\item W dalszym etapie porównywania modeli skupimy siê na porównaniach  krzywych ROC i krzywych PR.
\end{iteration}

\subsection{Tworzenie modeli predykcyjnych}
W ramach tej czêsci bêdê wykorzystywa³ bibliotekê \verb+mlr+ do stworzenia 4 modeli:
\begin{itemize}
\item Logistic regression
\item Random forest
\item SVM
\item XGBoost
\end{itemize}
\subsubsection{Logistic Regresion}
<<echo=FALSE,message=FALSE,cache=TRUE>>= 

logistic_learner <- makeLearner("classif.logreg",
                                predict.type = "prob")
getParamSet("classif.logreg")



cv.logistic <- crossval(learner = logistic_learner,
                          task = trainTask,
                          iters = 5,
                          stratify = TRUE,
                          measures = f1,
                          show.info = F)

logistic_model <- train(logistic_learner, trainTask)
summary(getLearnerModel(logistic_model))
log_pred <- predict(logistic_model, testTask)
calculateROCMeasures(log_pred)


@
\subsubsection{Random Forest}
<<echo=FALSE,message=FALSE,cache=TRUE>>= 

rf_learner <- makeLearner("classif.randomForest", 
                          predict.type = "prob", 
                          par.vals = list(ntree = 200, mtry = 3))

getParamSet("classif.randomForest")

rf_params <- makeParamSet(
    makeIntegerParam("ntree", lower = 50, upper = 500),
    makeIntegerParam("mtry", lower = 3, upper = 10),
    makeIntegerParam("nodesize", lower = 10, upper = 50)
)

rf_control <- makeTuneControlRandom(maxit = 10)

resample_desc <- makeResampleDesc("CV", iters = 5)

rf_tune_params <- tuneParams(learner = rf_learner, 
                             resampling = resample_desc, 
                             task = trainTask, 
                             par.set = rf_params, 
                             control = rf_control,
                             measures = f1)

rf_tuned_learner <- setHyperPars(learner = rf_learner, 
                                 par.vals = rf_tune_params$x)
#########
rf_model <- train(rf_tuned_learner, trainTask)
# summary(getLearnerModel(rf_model))

rf_pred <- predict(rf_model, testTask)
calculateROCMeasures(rf_pred)


@
\subsubsection{SVM}
<<echo=FALSE,message=FALSE,cache=TRUE>>= 

ksvm_learner <- makeLearner("classif.ksvm", 
                    predict.type = "prob")

getParamSet("classif.ksvm")

ksvm_params <- makeParamSet(
    makeDiscreteParam("C", values = 2^c(-8,-4,-2,0)), #cost parameters
    makeDiscreteParam("sigma", values = 2^c(-8,-4,0,4)) #RBF Kernel Parameter
)
ctrl <- makeTuneControlGrid()

resample_desc <- makeResampleDesc("CV", iters = 5)

ksvm_tune_params <- tuneParams(learner = ksvm_learner, 
                  task = trainTask, 
                  resampling = resample_desc, 
                  par.set = ksvm_params, 
                  control = ctrl,
                  measures = f1)

ksvm_tuner_learner <- setHyperPars(learner = ksvm_learner, 
                                   par.vals = ksvm_tune_params$x)

#######
ksvm_model <- train(ksvm_tuner_learner, trainTask)
# summary(getLearnerModel(ksvm_model))

ksvm_pred <- predict(ksvm_model, testTask)
calculateROCMeasures(ksvm_pred)


@
\subsubsection{XGBoost}
<<echo=FALSE,message=FALSE,cache=TRUE>>= 

xgb_learner <- makeLearner(
    "classif.xgboost",
    predict.type = "prob",
    par.vals = list(
        objective = "binary:logistic",
        eval_metric = "error",
        nrounds = 200
    )
)

getParamSet("classif.xgboost")

xgb_params <- makeParamSet(
    makeIntegerParam("nrounds", lower = 100, upper = 1000),
    makeIntegerParam("max_depth", lower = 1, upper = 10),
    makeNumericParam("eta", lower = 0.025, upper = 0.5),
    makeNumericParam("gamma", lower = 0, upper = 1),
    makeNumericParam("min_child_weight", lower = 1, upper = 3),
    makeNumericParam("colsample_bytree", lower = 0.2, upper = 1), 
    makeNumericParam("lambda", lower = -1, upper = 0, trafo = function(x) 10^x)
)

xgb_control <- makeTuneControlRandom(maxit = 10)

resample_desc <- makeResampleDesc("CV", iters = 5)

xgb_tuned_params <- tuneParams(
    learner = xgb_learner,
    task = trainTask,
    resampling = resample_desc,
    par.set = xgb_params,
    control = xgb_control,
    measures = f1)

xgb_tuned_learner <- setHyperPars(
    learner = xgb_learner,
    par.vals = xgb_tuned_params$x)


#######
xgb_model <- train(xgb_tuned_learner, trainTask)
# summary(getLearnerModel(xgb_model))

xgb_pred <- predict(xgb_model, testTask)
calculateROCMeasures(xgb_pred)

@

\subsection{Krzywa ROC oraz krzywa PR}
<<echo=FALSE,message=FALSE,cache=TRUE>>= 

list_of_pred <- list(logistic = log_pred, 
                     random_forest = rf_pred,
                     SVM = ksvm_pred, 
                     XGBoost = xgb_pred)
list_of_measures = list(acc, ppv, tpr, tnr)
set.seed(2019)
score_test = generateThreshVsPerfData(obj = list_of_pred, 
                                      measures = list_of_measures)
score_test$data
fun_ROC_PR_curve_ggplot(score_test)


@
\subsection{Tabela miar}
<<echo=FALSE,message=FALSE,cache=TRUE>>= 
list_of_models <- list(logistic_learner, 
                     rf_tuned_learner,
                     ksvm_tuner_learner, 
                     xgb_tuned_learner)
rdesc = makeResampleDesc("CV", iters = 10)
list_of_measures = list(acc, ppv, tpr, tnr, auc, aucpr, f1)

set.seed(2019)
table_of_measure = benchmark(list_of_models, testTask, rdesc, measures = list_of_measures)
table_of_measure = data.frame(table_of_measure)
table_of_measure  <- table_of_measure %>%
    group_by(learner.id) %>%
    summarise(mean(acc), mean(ppv), mean(tpr), mean(tnr), mean(auc), mean(f1))

AUCPR = c( pr.curve(testTask$env$data$y, log_pred$data$response)[[2]],
          pr.curve(testTask$env$data$y, rf_pred$data$response)[[2]],
          pr.curve(testTask$env$data$y, ksvm_pred$data$response)[[2]],
          pr.curve(testTask$env$data$y, xgb_pred$data$response)[[2]])

table_of_measure %>%
    mutate(aucpr = AUCPR)



@

\section{Wnioski}




\end{document}
